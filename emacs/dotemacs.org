# Filename: dotemacs.org
# Note:     Emacs configuration, obviously.

* About
  My Emacs configuration written in literate programming style that would make
  Donald Knuth proud. Hopefully easier to read than a plain Elisp file.

  I keep a (relatively) lightweight config, separating default and third party
  settings for easier debugging. I don't like the idea of using too many
  plugins, so I try to keep them spare.
* Lexical Binding
  By default, Elisp does not have lexical binding, /i.e./ variable scope based on
  the position of text which virtually every other mainstream language has. So
  let's enable it.

  #+BEGIN_SRC emacs-lisp
    ;; -*- lexical-binding: t -*-
  #+END_SRC

* Vanilla
  Stock Emacs settings without any third party packages.
** Custom Settings
   Designate a separate file for custom-set-variables under .emacs.d, name it
   custom.el, and load the file on startup.

  #+BEGIN_SRC emacs-lisp
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
    (load custom-file 'noerror)
  #+END_SRC

** Dired
   Directory editor.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'dired-mode-hook 'hl-line-mode)
   #+END_SRC

** Encoding
   Gotta have that 8-bit Unicode.

   #+BEGIN_SRC emacs-lisp
     (prefer-coding-system 'utf-8)
     (setq default-buffer-file-coding-system 'utf-8)
   #+END_SRC

** Environment
*** Default Directory (Mac)
    Since Emacs 27, Emacs doesn't set the default directory to home, at least on
    Mac.

    #+BEGIN_SRC emacs-lisp
      (when (equal system-type 'darwin)
        (setq default-directory "~/"))
    #+END_SRC

** File IO
   Behavior when loading files in Emacs.
*** Auto Revert
    Reload files automatically when detecting changes made outside of Emacs like
    every contemporary editor.

    #+BEGIN_SRC emacs-lisp
      (global-auto-revert-mode 1)
    #+END_SRC

*** Backups
    Disable file backups, at least for now.

    1. Don't auto-save files.
    2. Don't create backup files (yeah, yeah).
    3. Don't create lock files.

    #+BEGIN_SRC emacs-lisp
      (setq auto-save-default nil
            create-lockfiles nil
            make-backup-files nil)
    #+END_SRC

** Ibuffer
   Just sprinkle in some jk.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'ibuffer-mode-hook '(lambda () (local-set-key (kbd "G") 'end-of-buffer)))
     (add-hook 'ibuffer-mode-hook '(lambda () (local-set-key (kbd "R") 'ibuffer-do-replace-regexp)))
     (add-hook 'ibuffer-mode-hook '(lambda () (local-set-key (kbd "g") 'beginning-of-buffer)))
     (add-hook 'ibuffer-mode-hook '(lambda () (local-set-key (kbd "j") 'next-line)))
     (add-hook 'ibuffer-mode-hook '(lambda () (local-set-key (kbd "k") 'previous-line)))
     (add-hook 'ibuffer-mode-hook '(lambda () (local-set-key (kbd "r") 'ibuffer-update)))
   #+END_SRC

   And some other stuff.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'ibuffer-mode-hook 'hl-line-mode)
   #+END_SRC

** Ido
   Interactive do.
   1. Disable file matching when opening files.
   2. Ignore case.
   3. Enable flexible matching.
   4. Enable Ido where applicable, /e.g./ finding files, /etc./
   5. Enable Ido.

   #+BEGIN_SRC emacs-lisp
     (setq ido-auto-merge-work-directories-length -1
           ido-case-fold t
           ido-enable-flex-matching t
           ido-everywhere t)

     (ido-mode 1)
   #+END_SRC

** Isearch
   The interactive search, no?
*** Keybindings
    #+BEGIN_SRC emacs-lisp
      (setq uvar:isearch-mode-keybindings
            '(("<up>"   . isearch-repeat-backward)
              ("<down>" . isearch-repeat-forward)))

      (add-hook 'isearch-mode-hook
                '(lambda ()
                   (dolist (bindings uvar:isearch-mode-keybindings)
                     (define-key isearch-mode-map
                       (kbd (car bindings)) (cdr bindings)))))
    #+END_SRC

** Keybindings
   Click clack.
*** Custom
    Don't really use these too much, but navigating between splits is super
    helpful.

    #+BEGIN_SRC emacs-lisp
      (setq uvar:emacs-custom-keybindings
            '(("<M-down>"  . windmove-down)
              ("<M-left>"  . windmove-left)
              ("<M-right>" . windmove-right)
              ("<M-up>"    . windmove-up)))

      (dolist (keybindings uvar:emacs-custom-keybindings)
        (global-set-key (kbd (car keybindings)) (cdr keybindings)))
    #+END_SRC

** Language Modes
   Settings for default modes that support various languages, text, /etc./
*** C/C++
    Old school cool.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'c-mode-hook   'flyspell-prog-mode)
      (add-hook 'c++-mode-hook 'flyspell-prog-mode)
    #+END_SRC

*** Emacs Lisp
    Flight school, space cadet.

     #+BEGIN_SRC emacs-lisp
       (add-hook 'emacs-lisp-mode-hook 'flyspell-prog-mode)
       (add-hook 'emacs-lisp-mode-hook 'prettify-symbols-mode)
     #+END_SRC

*** LaTeX
    In the beginning, before Markdown.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'latex-mode-hook '(lambda () (setq-local fill-column uvar:default-column)))
      (add-hook 'latex-mode-hook 'flyspell-mode)
    #+END_SRC

*** Shell Scripting
    Lawful evil scripting.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'sh-mode-hook 'flyspell-prog-mode)
    #+END_SRC

*** Text
    Real plain text.

    #+BEGIN_SRC emacs-lisp
      (setq uvar:text-column 72)
      (add-hook
       'text-mode-hook '(lambda () (setq-local fill-column uvar:text-column))) ; blame Git
      (add-hook
       'text-mode-hook '(lambda () (setq-local whitespace-line-column uvar:text-column))) ; same
      (add-hook 'text-mode-hook 'flyspell-mode)
      (add-to-list 'auto-mode-alist '("COMMIT_EDITMSG" . text-mode))
    #+END_SRC

** Mouse
*** Selection
    Delete a selected region by simply typing any character(s).

    #+BEGIN_SRC emacs-lisp
      (delete-selection-mode t)
    #+END_SRC

    Copy, /i.e./ save to kill ring, automatically when dragging mouse over region.

    #+BEGIN_SRC emacs-lisp
      (setq mouse-drag-copy-region 1)
    #+END_SRC

** Org
   Some Org Mode settings... Maybe one day you'll bother labeling these out.

   #+BEGIN_SRC emacs-lisp
     (setq org-enforce-todo-dependencies t
           org-hide-emphasis-markers t
           org-src-fontify-natively t
           org-src-tab-acts-natively t
           org-time-stamp-formats '("<%Y_%m_%d %a>" .
                                    "<%Y_%m_%d %a %H:%M>")
           org-todo-keywords '((sequence "TODO(t)"
                                         "IN-PROGRESS(p!)"
                                         "BLOCKED(b@/!)"
                                         "SOMEDAY(s@/!)"
                                         "|"
                                         "DONE(d!)"
                                         "CANCELED(c@/!)"))
           org-use-fast-todo-selection t)
     (add-hook 'org-mode-hook '(lambda () (setq-local fill-column uvar:default-column)))
     (add-hook 'org-mode-hook '(lambda () (setq-local whitespace-line-column uvar:default-column)))
   #+END_SRC

** Package Menu
   Just sprinkle in some jk.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'package-menu-mode-hook 'hl-line-mode)
     (add-hook 'package-menu-mode-hook '(lambda () (local-set-key (kbd "G")  'end-of-buffer)))
     (add-hook 'package-menu-mode-hook '(lambda () (local-set-key (kbd "gg") 'beginning-of-buffer)))
     (add-hook 'package-menu-mode-hook '(lambda () (local-set-key (kbd "j")  'next-line)))
     (add-hook 'package-menu-mode-hook '(lambda () (local-set-key (kbd "k")  'previous-line)))
   #+END_SRC

** Paths
   Tell Emacs where it should look for ancillary Elisp, binaries, /etc./
*** Bin
    Running Emacs on Mac or Windows typically involves explicitly pointing to
    binaries on disk via setting the PATH and exec-path variables in order to
    get some extended functionality.

    *Shells and subprocess* within Emacs typically use the PATH variable to refer
    to external binaries.

    *Elisp programs* like diff tools, file compressors, spellcheckers, /etc/
    typically use the exec-path variable.

**** Mac
     These settings exist mostly to find Homebrew binaries.

     #+BEGIN_SRC emacs-lisp
       (when (equal system-type 'darwin)
         (let ((mac-binaries '("/usr/local/bin")))
           (setenv "PATH" (mapconcat 'identity mac-binaries path-separator))
           (dolist (binaries mac-binaries) (add-to-list 'exec-path binaries))))
     #+END_SRC

** Server
   Akuma!

   #+BEGIN_SRC emacs-lisp
     (require 'server)
     (unless (server-running-p) (server-start))
   #+END_SRC

** Spellcheck
   Use aspell for spell checking.

   #+BEGIN_SRC emacs-lisp
     (cond ((equal system-type 'gnu/linux)
            (setq ispell-program-name "/usr/bin/aspell"))
           ((equal system-type 'darwin)
            (setq ispell-progam-name "/usr/local/bin/aspell")))
   #+END_SRC

** Text
   Plain text behavior.
*** Backspace
    Backspace to the nearest non-whitespace character.

    #+BEGIN_SRC emacs-lisp
      (setq backward-delete-char-untabify-method 'hungry)
    #+END_SRC

*** Newlines
    Always add a newline at the end of a file.

    #+BEGIN_SRC emacs-lisp
      (setq require-final-newline t)
    #+END_SRC

*** Pairs
    Like peas in a pod.

    #+BEGIN_SRC emacs-lisp
      (setq show-paren-delay 0)
      (show-paren-mode 1)
    #+END_SRC

*** Sentences
    When formatting sentences with fill-column, separate joined sentences with
    one space instead of two spaces (default).

    #+BEGIN_SRC emacs-lisp
      (setq sentence-end-double-space nil)
    #+END_SRC

*** Tabs
    A tab means two spaces.

    #+BEGIN_SRC emacs-lisp
      (setq-default indent-tabs-mode nil)
      (setq-default tab-width 2)
      (setq c-basic-offset 2)
    #+END_SRC

*** Whitespace
    Cleanup whitespace before writing buffers.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'before-save-hook 'whitespace-cleanup)
    #+END_SRC

*** Words
    Read camelCase as two words.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'prog-mode-hook 'subword-mode)
    #+END_SRC

** User Interface
   General UI settings.
*** Columns
    Count columns starting from 1, /i.e./ the default is 0.

    #+BEGIN_SRC emacs-lisp
      (setq-default column-number-indicator-zero-based nil)
      (setq column-number-mode t)
    #+END_SRC

    Set column limit to 80 and mark anything exceeding 80 columns when
    whitespace-mode is enabled.

    #+BEGIN_SRC emacs-lisp
      (setq uvar:default-column 80)
      (setq-default fill-column uvar:default-column)
      (setq-default whitespace-line-column fill-column)
    #+END_SRC

*** Cursor
    Blinking cursors forever.

    #+BEGIN_SRC emacs-lisp
      (blink-cursor-mode 1)
      (setq blink-cursor-blinks 0)
    #+END_SRC

    Enable the cursor when running as a TTY.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'server-visit-hook '(lambda () (xterm-mouse-mode 1)))
    #+END_SRC

*** Disable
    Turn these off, thank you.

    #+BEGIN_SRC emacs-lisp
      (global-hl-line-mode -1)
      (menu-bar-mode -1)
      (scroll-bar-mode -1)
      (tool-bar-mode -1)
    #+END_SRC

    Don't display anything in the frame title and disable the startup screen.

    #+BEGIN_SRC emacs-lisp
      (setq frame-title-format nil inhibit-startup-screen t)
    #+END_SRC

*** Font
    Make sure the OS has the font installed!

    #+BEGIN_SRC emacs-lisp
      (set-frame-font "Inconsolata-15" nil t)
    #+END_SRC

*** Frames
    Basically windows in almost every other editor.
**** Default Size
     Dimensions of the frame on load.

     #+BEGIN_SRC emacs-lisp
       (setq initial-frame-alist '((width . 100) (height . 48)))
     #+END_SRC

**** Focusing
     Render non-focused frames transparent.

     /I.e./ when setting the alpha or transparency level, the first number
     indicates the transparency when focused and the second number, the
     transparency when unfocused. An alpha of 100 means opaque.

     #+BEGIN_SRC emacs-lisp
       (set-frame-parameter (selected-frame) 'alpha '(100 . 97))
       (add-to-list 'default-frame-alist '(alpha . (100 . 97)))
     #+END_SRC

*** Line Numbers
    Keep line numbers in uniform width, /i.e./ if the file has 100 lines then
    single and double digit numbers take up three spaces.

    #+BEGIN_SRC emacs-lisp
      (setq display-line-numbers-grow-only t)
    #+END_SRC

*** Minibuffer
    Wrap long lines within the minibuffer.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'minibuffer-setup-hook '(lambda () (setq truncate-lines nil)))
    #+END_SRC

*** Scrolling
    Do not allow over-scrolling.

    Emacs limits scrolling when the last non-empty line reaches the top of the
    current window instead of at the bottom like virtually every other modern
    text editor. According to the documentation however, this feature only works
    when running Emacs on X11.

    #+BEGIN_SRC emacs-lisp
      (setq scroll-bar-adjust-thumb-portion nil)
    #+END_SRC

    Configure smooth scrolling behavior. Not sure if these setting do anything really.

    #+BEGIN_SRC emacs-lisp
      (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))
            mouse-wheel-progressive-speed nil
            mouse-wheel-follow-mouse 't
            scroll-preserve-screen-position t
            scroll-step 1)
    #+END_SRC

*** Scratch Buffer
    Get in the text editor!

    #+BEGIN_SRC emacs-lisp
      (setq initial-scratch-message
            ";; God's in his heaven. All's right with the world. ")
    #+END_SRC

*** User Input
**** Visual Bell
     Flash the window when doing something that Emacs doesn't understand.

     #+BEGIN_SRC emacs-lisp
       (setq visible-bell 1)
     #+END_SRC

**** Yes/No Input
     Replace "y" and "n" for "yes" and "no" respectively. Why wouldn't you want
     this feature?

     #+BEGIN_SRC emacs-lisp
       (defalias 'yes-or-no-p 'y-or-n-p)
     #+END_SRC

** Utility Functions
   Some homebrewed Lisp.

   #+BEGIN_SRC emacs-lisp
     (defun ufun:add-word-to-dictionary ()
       "Add the word-at-point to aspell's dictionary."
       (interactive)
       (let ((current-location (point)) (word (flyspell-get-word)))
         (when (consp word)
           (flyspell-do-correct 'save
                                nil
                                (car word)
                                current-location
                                (cadr word)
                                (caddr word)
                                current-location))))

     (defun ufun:goto-previous-buffer ()
       "Return to the previously visited buffer. This function is
          interactive."
       (interactive)
       (switch-to-buffer (other-buffer (current-buffer) 1)))

     (defun ufun:kill-filepath ()
       "Copy the current buffer filename with path to clipboard. This
          function is interactive."
       (interactive)
       (let ((filepath (if (equal major-mode 'dired-mode)
                           default-directory
                         (buffer-file-name))))
         (when filepath
           (kill-new filepath)
           (message "Copied buffer filepath '%s' to clipboard." filepath))))
   #+END_SRC

** Version Control
   Prefer the CLI for this sort of thing. Sorry, no Magit for me.

   #+BEGIN_SRC emacs-lisp
     (setq vc-handled-backends nil)
   #+END_SRC

* Prelude: Local Configuration
  Load a local settings file named /prelude.el/ if it exists on disk, and don't
  throw a warning if it doesn't.

  Sometimes you need a local settings file for stuff like proxy configuration,
  /etc./ You should also put the following code snippet /before/ telling Emacs to
  make any sort of network connection like downloading packages.

  #+BEGIN_SRC emacs-lisp
    (load "~/Documents/src/dotfiles/emacs/lisp/prelude" 1)
  #+END_SRC

* Packages
  Settings for third party Elisp packages.
** Remote Repositories
   Configurations for third party packages.

   Load and activate Lisp packages.

   #+BEGIN_SRC emacs-lisp
     (require 'package)
     (package-initialize)
   #+END_SRC

   Set remote package repositories.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'package-archives '("gnu"   . "https://elpa.gnu.org/packages/") t)
     (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
   #+END_SRC

   Use use-package.

   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))
   #+END_SRC

   Require bind and diminish.

   #+BEGIN_SRC emacs-lisp
     (use-package bind-key
       :ensure t)

     (use-package diminish
       :ensure t
       :config
       (setq uvar:diminished-modes
             '(auto-fill-function ; = auto-fill-mode
               eldoc-mode))

       (dolist (diminished uvar:diminished-modes) (diminish diminished))

       (setq uvar:forced-diminished-modes '((subword . subword-mode)))

       (dolist (diminished uvar:forced-diminished-modes)
         (with-eval-after-load (car diminished) (diminish (cdr diminished)))))
   #+END_SRC

** Aesthetic
*** Theme
    This is (not) a compiler stream.

    #+BEGIN_SRC emacs-lisp
      (use-package naysayer-theme
        :ensure t
        :demand
        :config (load-theme 'naysayer t))
    #+END_SRC

*** Org

    #+BEGIN_SRC emacs-lisp
      (use-package org-bullets
        :ensure t
        :defer t
        :hook ((org-mode . hl-line-mode)
               (org-mode . org-bullets-mode)))
    #+END_SRC

** Productivity
   Useful tools that didn't make it into core for whatever reason.
*** Browse Kill Ring
    Provides a nice interactive buffer that shows all the stuff in the kill
    ring.

    #+BEGIN_SRC emacs-lisp
      (use-package browse-kill-ring
        :ensure t
        :defer t
        :hook ((browse-kill-ring-mode . (lambda () (local-set-key (kbd "j") 'browse-kill-ring-forward)))
               (browse-kill-ring-mode . (lambda () (local-set-key (kbd "k") 'browse-kill-ring-previous)))))
    #+END_SRC

*** Company
    The de facto completion framework for Emacs.

    #+BEGIN_SRC emacs-lisp
      (use-package company
        :ensure t
        :defer t
        :diminish company-mode
        :init (global-company-mode)
        :config
        (setq company-idle-delay 0)
        (setq-default company-dabbrev-downcase nil)
        (setq-default company-dabbrev-ignore-case 1)
        (with-eval-after-load 'company
          (define-key company-active-map (kbd "M-n") nil)
          (define-key company-active-map (kbd "M-p") nil)
          (define-key company-active-map (kbd "C-n") #'company-select-next)
          (define-key company-active-map (kbd "C-t") #'company-select-previous)))
    #+END_SRC

*** Evil
    Summon the Editor of the Beast - /vi vi vi./

    #+BEGIN_SRC emacs-lisp
      (use-package evil
        :ensure t
        :demand
        :config
        (evil-mode 1)
        (evil-select-search-module 'evil-search-module 'evil-search) ; TODO: set to 'isearch when in Org
        (use-package undo-fu
          :ensure t
          :config
          (define-key evil-normal-state-map "u"    'undo-fu-only-undo)
          (define-key evil-normal-state-map "\C-r" 'undo-fu-only-redo)))
    #+END_SRC

    Keybindings setup. Don't change default vi (too much).

    #+BEGIN_SRC emacs-lisp
      (setq uvar:evil-motion-state-rebindings
            '((";"  . evil-ex)
              (":"  . evil-repeat-find-char)
              ("gc" . comment-dwim)
              ("zg" . ufun:add-word-to-dictionary)))

      ;; TODO: Make this into a general function or macro.
      (dolist (keybindings uvar:evil-motion-state-rebindings)
        (define-key evil-motion-state-map
          (kbd (car keybindings)) (cdr keybindings)))

      ;; Need Ctr-Z for Emacsclient.
      (define-key evil-motion-state-map (kbd "M-m") 'evil-emacs-state)
      (define-key evil-motion-state-map (kbd "C-z") 'suspend-frame)
      (define-key evil-emacs-state-map  (kbd "M-m") 'evil-exit-emacs-state)
      (define-key evil-emacs-state-map  (kbd "C-z") 'suspend-frame)
    #+END_SRC

    Leader keybindings setup with vanilla Emacs. No extra plugins like
    Evil Leader, General, /etc/ necessary.

    #+BEGIN_SRC emacs-lisp
      (define-prefix-command 'uvar:evil-leader-keymap)

      (with-eval-after-load 'evil-maps
        (define-key evil-motion-state-map
          (kbd "<SPC>") 'uvar:evil-leader-keymap))

      (setq uvar:evil-leader-bindings
            '(("lc" . count-words-region)
              ("le" . ufun:evil-apply-macro-to-region-lines)
              ("ls" . sort-lines)
              ("r"  . ufun:goto-previous-buffer)
              ("O"  . switch-to-buffer-other-window)
              ("o"  . switch-to-buffer)
              ("E"  . find-file-other-window)
              ("e"  . find-file)
              ("dG" . end-of-buffer)                         ; TODO: make this dired specific
              ("dg" . beginning-of-buffer)                   ; "
              ("dw" . wdired-change-to-wdired-mode)          ; "
              ("ty" . browse-kill-ring)                      ; binding here b/c it's called after :/
              ("tw" . whitespace-mode)
              ("sp" . ufun:kill-filepath)
              ("b"  . ibuffer)))

      ;; TODO: Make this into a general function or macro.
      (dolist (keybindings uvar:evil-leader-bindings)
        (define-key uvar:evil-leader-keymap
          (kbd (car keybindings)) (cdr keybindings)))

      ;; Apply leader binding when in Dired.
      (add-hook 'dired-mode-hook
                '(lambda () (local-set-key (kbd "SPC") 'uvar:evil-leader-keymap)))
    #+END_SRC

    Nobody hits escape.

    #+BEGIN_SRC emacs-lisp
      (use-package evil-escape
        :ensure t
        :diminish
        :config
        (evil-escape-mode t)
        (setq-default evil-escape-key-sequence "hh"
                      evil-escape-excluded-states '(normal visual motion)
                      evil-escape-delay 0.2))
    #+END_SRC

    Increment/decrement numbers like in Vim.

    #+BEGIN_SRC emacs-lisp
      (use-package evil-numbers
        :ensure t
        :config
        (define-key evil-normal-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
        (define-key evil-normal-state-map (kbd "C-x") 'evil-numbers/dec-at-pt))
    #+END_SRC

    Emulate Tpope's Surround Vim plugin.

    #+BEGIN_SRC emacs-lisp
      (use-package evil-surround
        :ensure t
        :config
        (global-evil-surround-mode 1))
    #+END_SRC

    User Evil function(s).

    #+BEGIN_SRC emacs-lisp
      (defun ufun:evil-apply-macro-to-region-lines ()
        "Easy binding for running an Evil macro over some selected lines."
        (interactive)
        (evil-ex "'<,'>norm@"))
    #+END_SRC

*** Exec Path From Shell (Mac Only)
    Emacs needs some help loading PATH variables when on Mac.

    #+BEGIN_SRC emacs-lisp
      (use-package exec-path-from-shell
        :if (memq window-system '(mac ns))
        :ensure t
        :defer 5
        :config
        (exec-path-from-shell-initialize))
    #+END_SRC

*** Flycheck
    Asynchronous linting, /etc./

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck
        :ensure t
        :defer t
        :diminish flycheck-mode)
    #+END_SRC

*** Projectile
    Project management. Note, you need to tell Emacs to use a POSIX shell for
    this package to work correctly. It won't play nice with something like Fish
    OOTB.

    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :ensure t
        :defer t
        :bind (:map uvar:evil-leader-keymap
                    ("pR" . projectile-replacae-regexp)
                    ("pS" . projectile-switch-project)
                    ("pa" . projectile-add-known-project)
                    ("pb" . projectile-switch-to-buffer)
                    ("pd" . projectile-remove-known-project)
                    ("pf" . projectile-find-file)
                    ("pk" . projectile-kill-buffers)
                    ("pr" . projectile-replace)
                    ("ps" . projectile-switch-open-project)
                    ("pw" . projectile-save-project-buffers))
        :config
        (setq shell-file-name "/bin/sh")
        (setq projectile-completion-system  'ido
              projectile-mode-line-function '(lambda () (format " P[%s]" (ufun:projectile-display-project-name)))
              projectile-sort-order         'recentf)
        (projectile-mode +1))
    #+END_SRC

    User Projectile function(s).

    #+BEGIN_SRC emacs-lisp
      (defun ufun:projectile-display-project-name ()
        "Return the project name as determined by Projectile if 10 characters or less.
      Otherwise, truncate the name."
        (let ((cutoff 20)
              (name (projectile-project-name)))
          (if (>= cutoff (string-width name))
              name
            (concat (truncate-string-to-width name cutoff) ".."))))
    #+END_SRC

*** Smex
    Extend Ido functionality for M-x.

    #+BEGIN_SRC emacs-lisp
      (use-package smex
        :ensure t
        :defer t
        :bind (("M-x" . smex)
               ("M-X" . execute-extended-command)
               :map uvar:evil-leader-keymap
               ("m" . smex)))
    #+END_SRC

*** Which Key
    Dynamic menu helpful for learning keybindings.

    #+BEGIN_SRC emacs-lisp
      (use-package which-key
        :ensure t
        :defer 2
        :diminish which-key-mode
        :config
        (setq which-key-idle-delay 0.1
              which-key-sort-order 'which-key-key-order-alpha)
        (setq uvar:which-key-evil-leader-labels
              '(("<SPC> p" . "project actions")
                ("<SPC> l" . "line actions")
                ("<SPC> r" . "visit last buffer")
                ("<SPC> O" . "open buffer in other window")
                ("<SPC> o" . "open buffer")
                ("<SPC> E" . "edit file in other window")
                ("<SPC> e" . "edit file")
                ("<SPC> d" . "directory actions")
                ("<SPC> t" . "text actions")
                ("<SPC> s" . "special actions")
                ("<SPC> b" . "buffer menu")
                ("<SPC> m" . "toplevel")))

        ;; TODO: Make this into a general function or macro.
        (dolist (labels uvar:which-key-evil-leader-labels)
          (which-key-add-key-based-replacements (car labels) (cdr labels)))

        (which-key-mode))
    #+END_SRC

** Programming Languages
   Third party plugins for working with programming languages that core doesn't
   support.
*** Fish
    Gone fishing.

    #+BEGIN_SRC emacs-lisp
      (use-package fish-mode
        :ensure t
        :defer t
        :hook ((fish-mode . flyspell-prog-mode))
        :config (setq fish-indent-offset 2))
    #+END_SRC

*** Gitignore
    Yeah, this doesn't come out of the box.

    #+BEGIN_SRC emacs-lisp
      (use-package gitignore-mode
        :ensure t
        :defer t
        :hook ((gitignore-mode . flyspell-prog-mode)))
    #+END_SRC

*** Haskell
    The polymorphic, lazily evaluated, runtime lambda calculus with algebraic
    data types.

    #+BEGIN_SRC emacs-lisp
      (use-package haskell-mode
        :ensure t
        :defer t
        :hook ((haskell-mode . flycheck-mode)
               (haskell-mode . flyspell-prog-mode)))
    #+END_SRC

*** JSON
    Yet another... Wait. That's the other one.

    #+BEGIN_SRC emacs-lisp
      (use-package json-mode
        :ensure t
        :defer t
        :hook ((json-mode . flycheck-mode)
               (json-mode . flyspell-prog-mode))
        :config
        (setq js-indent-level 2)
        (add-to-list 'auto-mode-alist '("\\.eslintrc\\'"   . json-mode))
        (add-to-list 'auto-mode-alist '("\\.prettierrc\\'" . json-mode)))
    #+END_SRC

*** Markdown
    People like it. Seems okay.

    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
        :ensure t
        :defer t
        :commands (markdown-mode gfm-mode)
        :mode (("README\\.md\\'" . gfm-mode))
        :hook ((markdown-mode . flycheck-mode)
               (markdown-mode . flyspell-mode)
               (markdown-mode . (lambda () (setq-local fill-column uvar:default-column)))
               (markdown-mode . (lambda () (setq-local whitespace-line-column uvar:default-column))))
        :config
        (cond ((string-equal system-type "gnu/linux")
               (setq markdown-command "/usr/bin/pandoc"))
              ((string-equal system-type "darwin")
               (setq markdown-command "/usr/local/bin/pandoc"))))
    #+END_SRC

*** TypeScript
    Hater, hater static type chaser.

    #+BEGIN_SRC emacs-lisp
      (use-package typescript-mode
        :ensure t
        :defer t
        :hook ((typescript-mode . (lambda () (push '("=>" . 8658) prettify-symbols-alist)))
               (typescript-mode . flycheck-mode)
               (typescript-mode . flyspell-prog-mode)
               (typescript-mode . prettify-symbols-mode)))
    #+END_SRC

*** YAML
    Whitespace JSON?

    #+BEGIN_SRC emacs-lisp
      (use-package yaml-mode
        :ensure t
        :defer t
        :hook ((yaml-mode-hook . flycheck-mode)
               (yaml-mode-hook . flyspell-prog-mode)))
    #+END_SRC

* Coda: Local Configuration
  Load a local settings file named /coda.el/ if it exists on disk, and don't throw
  a warning if it doesn't.

  A local settings file comes handy when configuring work specific settings. The
  following code snippet should come /after/ loading everything else to Emacs.

  #+BEGIN_SRC emacs-lisp
    (load "~/Documents/src/dotfiles/emacs/lisp/coda" 1)
  #+END_SRC
